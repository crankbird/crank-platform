"""
Codex Zettel Repository Worker

This worker ingests zettels generated by conversational agents (e.g., ChatGPT)
and persists them to a structured repository. The implementation favors clear
extension points for future capabilities such as auto-titling, categorization,
similarity-based storage, and publication/export workflows.
"""

from __future__ import annotations

import asyncio
import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any

from fastapi import HTTPException
from fastapi.responses import JSONResponse

from crank.capabilities.schema import CODEX_ZETTEL_REPOSITORY, CapabilityDefinition
from crank.worker_runtime.base import WorkerApplication

logger = logging.getLogger(__name__)


@dataclass(slots=True)
class ZettelRepositoryConfig:
    """Runtime configuration for the Codex zettel repository."""

    base_path: Path = field(default_factory=lambda: Path("zettels_repository"))
    default_category: str = "inbox"
    file_extension: str = ".md"


@dataclass(slots=True)
class ZettelRecord:
    """Structured representation of a single zettel."""

    zettel_id: str
    title: str
    content: str
    category: str | None = None
    tags: list[str] = field(default_factory=list)
    source_agent: str | None = None
    metadata: dict[str, Any] = field(default_factory=dict)
    context: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)


class ZettelRepository:
    """Primitive filesystem repository for storing zettels."""

    def __init__(self, config: ZettelRepositoryConfig | None = None) -> None:
        self.config = config or ZettelRepositoryConfig()
        self.base_path = self.config.base_path.expanduser().resolve()
        self.base_path.mkdir(parents=True, exist_ok=True)
        self.config.base_path = self.base_path

    def store(self, record: ZettelRecord) -> Path:
        """Persist a zettel as a Markdown file with JSON front matter."""
        category = self._sanitize_segment(record.category or self.config.default_category)
        target_dir = self.base_path / category
        target_dir.mkdir(parents=True, exist_ok=True)

        file_name = f"{self._sanitize_segment(record.zettel_id)}{self.config.file_extension}"
        target_path = target_dir / file_name
        target_path.write_text(self._render_record(record), encoding="utf-8")
        return target_path

    def _render_record(self, record: ZettelRecord) -> str:
        metadata = {
            "zettel_id": record.zettel_id,
            "title": record.title,
            "category": record.category or self.config.default_category,
            "tags": record.tags,
            "source_agent": record.source_agent,
            "created_at": record.created_at.isoformat(),
            "metadata": record.metadata,
            "context": record.context,
        }
        front_matter = json.dumps(metadata, indent=2, sort_keys=True, default=str)
        body = record.content.rstrip() + "\n"
        return f"---\n{front_matter}\n---\n\n{body}"

    def _sanitize_segment(self, raw_value: str) -> str:
        slug = "".join(ch if ch.isalnum() or ch in ("-", "_") else "-" for ch in raw_value.strip().lower())
        slug = "-".join(filter(None, slug.split("-")))
        return slug or "zettel"


class CodexZettelService:
    """
    Core domain service coordinating ingestion workflows.

    The service intentionally exposes helper hooks (_generate_title,
    _resolve_category, etc.) so future enhancements (auto-categorization,
    similarity lookups, publication requests) can plug in without rewriting
    the worker entrypoints.
    """

    def __init__(self, repository: ZettelRepository) -> None:
        self.repository = repository

    def ingest(self, payload: dict[str, Any]) -> dict[str, Any]:
        record = self._build_record(payload)
        self._ensure_title(record)
        self._ensure_category(record)

        stored_path = self.repository.store(record)
        relative_path = stored_path.relative_to(self.repository.base_path)

        return {
            "zettel_id": record.zettel_id,
            "title": record.title,
            "category": record.category,
            "tags": record.tags,
            "storage_path": str(stored_path),
            "relative_path": str(relative_path),
            "repository_root": str(self.repository.base_path),
            "created_at": record.created_at.isoformat(),
        }

    def _build_record(self, payload: dict[str, Any]) -> ZettelRecord:
        content = (payload.get("content") or "").strip()
        if not content:
            raise ValueError("content is required for zettel ingestion")

        zettel_id = (payload.get("zettel_id") or self._generate_zettel_id()).strip()
        title = (payload.get("title") or "").strip()
        category = (payload.get("category") or "").strip() or None
        tags = self._normalize_tags(payload.get("tags"))
        metadata = self._ensure_mapping(payload.get("metadata"), "metadata")
        context = self._ensure_mapping(payload.get("context"), "context")
        source_agent = (payload.get("source_agent") or "").strip() or None

        return ZettelRecord(
            zettel_id=zettel_id,
            title=title,
            content=content,
            category=category,
            tags=tags,
            source_agent=source_agent,
            metadata=metadata,
            context=context,
        )

    def _ensure_title(self, record: ZettelRecord) -> None:
        if not record.title:
            record.title = self._generate_title(record)

    def _ensure_category(self, record: ZettelRecord) -> None:
        record.category = record.category or self._resolve_category(record)

    def _generate_zettel_id(self) -> str:
        timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
        return f"zk{timestamp}"

    def _generate_title(self, record: ZettelRecord) -> str:
        """
        Extension hook for auto-title generation.

        Currently derives a simple summary from the first line but can be
        replaced with semantic summarisation later.
        """
        first_line = record.content.strip().splitlines()[0]
        return first_line[:80] or f"zettel-{record.zettel_id}"

    def _resolve_category(self, record: ZettelRecord) -> str:
        """
        Extension hook for routing/categorisation strategies.

        Future versions can inspect record metadata or run similarity checks.
        """
        return self.repository.config.default_category

    def _normalize_tags(self, value: Any) -> list[str]:
        if value is None:
            return []
        if isinstance(value, str):
            return [value]
        if isinstance(value, list):
            return [str(tag).strip() for tag in value if str(tag).strip()]
        raise ValueError("tags must be a list of strings or a single string")

    def _ensure_mapping(self, value: Any, field_name: str) -> dict[str, Any]:
        if value is None:
            return {}
        if isinstance(value, dict):
            return value
        raise ValueError(f"{field_name} must be a JSON object")

    # ------------------------------------------------------------------ #
    # Future extension hooks (publication / retrieval workflows)
    # ------------------------------------------------------------------ #

    def plan_publication(self, _criteria: dict[str, Any]) -> list[dict[str, Any]]:
        """Placeholder for future publication planning support."""
        raise NotImplementedError("Publication planning is not implemented yet")

    def retrieve_matching(self, _filters: dict[str, Any]) -> list[dict[str, Any]]:
        """Placeholder for similarity-based retrieval features."""
        raise NotImplementedError("Retrieval filters are not implemented yet")


class CodexZettelRepositoryWorker(WorkerApplication):
    """Worker wiring for the Codex zettel repository capability."""

    def __init__(
        self,
        worker_id: str | None = None,
        service_name: str | None = None,
        https_port: int = 8500,
        repository_root: Path | str | None = None,
    ) -> None:
        self.repository_config = ZettelRepositoryConfig(
            base_path=Path(repository_root).expanduser()
            if repository_root
            else Path("zettels_repository")
        )
        self.service = CodexZettelService(ZettelRepository(self.repository_config))
        super().__init__(
            worker_id=worker_id,
            service_name=service_name or "codex-zettel-repository",
            https_port=https_port,
        )

    def setup_routes(self) -> None:
        async def ingest_zettel(request: dict[str, Any]) -> JSONResponse:
            try:
                result = self.service.ingest(request)
                return JSONResponse(content=result, status_code=201)
            except ValueError as exc:
                raise HTTPException(status_code=400, detail=str(exc)) from exc
            except Exception:
                logger.exception("Failed to store zettel")
                raise HTTPException(status_code=500, detail="ZETTEL_STORAGE_FAILED")

        self.app.post("/zettels")(ingest_zettel)

    def get_capabilities(self) -> list[CapabilityDefinition]:
        return [CODEX_ZETTEL_REPOSITORY]

    async def on_startup(self) -> None:
        logger.info("Codex zettel repository worker starting up")
        await super().on_startup()
        logger.info("Codex zettel repository ready")

    async def on_shutdown(self) -> None:
        logger.info("Codex zettel repository worker shutting down")
        await super().on_shutdown()


async def main() -> None:
    """Entrypoint for running the worker via `python services/...`."""
    import uvicorn

    worker = CodexZettelRepositoryWorker()
    config = uvicorn.Config(
        worker.app,
        host="0.0.0.0",
        port=8002,
        log_level="info",
    )
    server = uvicorn.Server(config)

    try:
        await server.serve()
    except KeyboardInterrupt:
        logger.info("Received shutdown signal")


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        worker = CodexZettelRepositoryWorker(repository_root=Path("zettels_repository_test"))
        print(f"Worker capabilities: {[cap.id for cap in worker.get_capabilities()]}")
        sample_payload = {
            "title": "Test zettel",
            "content": "This is a quick test of the Codex zettel repository worker.",
            "category": "experiments",
            "tags": ["test", "codex"],
            "source_agent": "codex-cli",
        }
        response = worker.service.ingest(sample_payload)
        print(f"Stored test zettel at {response['relative_path']}")
    else:
        asyncio.run(main())
